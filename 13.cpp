#include <iostream>
#include <cmath>
using namespace std;
int main(){
    const unsigned int DIM1 = 3;
    const unsigned int DIM2 = 5;

    int **ary;    // (1)

    // создание
    ary = new int * [DIM1];    // массив указателей (2)
    for (int i = 0; i < DIM1; i++) {   // (3)
        ary[i] = new int [DIM2];     // инициализация указателей
    }

    // уничтожение
    for (int i = 0; i < DIM1; i++) {
        delete [] ary[i];
    }
    delete [] ary;
/*
(1) Для доступа к двумерному массиву объявляется переменная ary типа указатель на указатель на тип (в данном случае это указатель на указатель на int).
(2) Переменная инициализируется оператором new, который выделяет память для массива указателей на int.
(3) В цикле каждый элемент массива указателей инициализируется оператором new, который выделяет память для массива типа int.
*/

// для работы с трехмерном метод аналогичен , кол-во циклов увеличиваеться до 2

    int arr[5] = {1, 2, 3, 4, 5};

    // 1 способ вывода массива
    for (int i = 0; i < 5; i++) {
        cout << *(arr + i) << endl; // Выводим элемент по указателю ,а после увеличиваем его
    }
    // 1 2 3 4 5

    int* arrLink = arr; // указатель на массив
    // 2 способ вывода массива
    for (int i = 0; i < 5; i++) {
        cout << *arrLink++ << endl; // Выводим элемент по указателю ,а после увеличиваем его
    }
    // 1 2 3 4 5

    //Вывод трехмерного пассива через указатели
    int arr2[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    int size = 3 * 3;
    for (int i = 0; i < size; i++) // пробегаемся по каждому одномерному массиву
        cout << *(arr2[0] + i) << endl; //Выводим одномерный массив через указатель
    // 1 2 3 4 5 6 7 8 9

    //Оптимизированный вывод НЕ динамического массива подходящий для массива любой длины
    int not_dinamic_array[] = {9,8,7,6,5};
    for (auto i : not_dinamic_array) // i тсановиться указателем на первый элемент массива, после чего он каждый раз увеличиваеться пока не дойдет до конца
        cout << i << endl;
    // 9 8 7 6 5


    return 0;
}